#!/usr/bin/env node

/**
 * Codex Father CLI ä¸»å…¥å£ç‚¹
 * å¯æ‰§è¡Œçš„ CLI å…¥å£è„šæœ¬ï¼Œæä¾›ç»Ÿä¸€çš„å‘½ä»¤è¡Œæ¥å£
 */

// æ£€æŸ¥ Node.js ç‰ˆæœ¬è¦æ±‚
const MIN_NODE_VERSION = 18;
const currentVersion = process.versions.node;
const majorVersion = parseInt(currentVersion.split('.')[0], 10);

if (majorVersion < MIN_NODE_VERSION) {
  console.error(`âŒ Error: Node.js ${MIN_NODE_VERSION}+ is required. Current version: ${currentVersion}`);
  console.error('Please upgrade Node.js: https://nodejs.org/');
  process.exit(1);
}

// é”™è¯¯è¾¹ç•Œï¼šæ•è·æœªå¤„ç†çš„å¼‚å¸¸
process.on('uncaughtException', (error) => {
  console.error('âŒ Uncaught Exception:', error.message);
  console.error('Stack trace:', error.stack);
  process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('âŒ Unhandled Rejection at:', promise, 'reason:', reason);
  process.exit(1);
});

// åŠ¨æ€å¯¼å…¥å¹¶å¯åŠ¨ CLI åº”ç”¨
async function main() {
  try {
    // æ ¹æ®ç¯å¢ƒé€‰æ‹©å…¥å£æ–‡ä»¶å’ŒåŠ è½½æ–¹å¼
    const isProduction = process.env.NODE_ENV === 'production';

    let app;

    if (isProduction) {
      // ç”Ÿäº§ç¯å¢ƒï¼šå°è¯•å¯¼å…¥æ„å»ºçš„ JavaScript æ–‡ä»¶
      try {
        app = await import('../dist/core/cli/start.js');
      } catch (importError) {
        console.error('âŒ Production build not found. Please run: npm run build');
        throw new Error('Production build is required in production mode');
      }
    } else {
      // å¼€å‘ç¯å¢ƒï¼šä½¿ç”¨ tsx åŠ è½½å™¨è¿è¡Œ TypeScript æ–‡ä»¶
      const { spawn } = await import('child_process');
      const path = await import('path');
      const { fileURLToPath } = await import('url');

      const __filename = fileURLToPath(import.meta.url);
      const __dirname = path.dirname(__filename);
      const tsxPath = path.resolve(__dirname, '../node_modules/.bin/tsx');
      const startTsPath = path.resolve(__dirname, '../core/cli/start.ts');

      // æ£€æŸ¥ tsx æ˜¯å¦å­˜åœ¨
      const fs = await import('fs');
      if (!fs.existsSync(tsxPath)) {
        console.error('âŒ tsx not found. Please run: npm install');
        process.exit(1);
      }

      // ä½¿ç”¨ tsx å¯åŠ¨ TypeScript æ–‡ä»¶
      const child = spawn('node', [tsxPath, startTsPath, ...process.argv.slice(2)], {
        stdio: 'inherit',
        env: { ...process.env, NODE_ENV: 'development' }
      });

      child.on('exit', (code) => {
        process.exit(code || 0);
      });

      child.on('error', (error) => {
        console.error('âŒ Failed to start CLI with tsx:', error.message);
        process.exit(1);
      });

      return; // é€€å‡ºï¼Œè®© tsx å¤„ç†å‰©ä½™çš„æ‰§è¡Œ
    }

    // å¯åŠ¨ CLI åº”ç”¨ï¼ˆä»…åœ¨ç”Ÿäº§ç¯å¢ƒï¼‰
    if (app.default && typeof app.default === 'function') {
      await app.default();
    } else if (app.startCLI && typeof app.startCLI === 'function') {
      await app.startCLI();
    } else {
      throw new Error('No valid CLI entry point found in the imported module');
    }
  } catch (error) {
    console.error('âŒ Failed to start Codex Father CLI:');
    console.error(`   ${error.message}`);

    // æä¾›æœ‰ç”¨çš„è°ƒè¯•ä¿¡æ¯
    if (error.code === 'MODULE_NOT_FOUND') {
      console.error('\nğŸ’¡ Suggestions:');
      console.error('   1. Run `npm install` to install dependencies');
      console.error('   2. Run `npm run build` to build the project');
      console.error('   3. Check that all required files exist');
    }

    // åœ¨å¼€å‘ç¯å¢ƒæ˜¾ç¤ºå®Œæ•´å †æ ˆ
    if (process.env.NODE_ENV === 'development' || process.env.DEBUG) {
      console.error('\nğŸ” Debug information:');
      console.error(error.stack);
    }

    process.exit(1);
  }
}

// å¯åŠ¨åº”ç”¨
main().catch((error) => {
  console.error('âŒ Fatal error during CLI startup:', error.message);
  process.exit(1);
});