# Product Requirements Document: MVP2 - 多进程并行管理

**Feature**: MVP2 Multi-Process Parallel Management **Version**: 1.0.0
**Created**: 2025-10-01 **Status**: Planning **Prerequisites**:
MVP1 完成（单进程 MCP 服务器已实现）

---

## 执行流程

```
1. 基于 MVP1 成果
   → ✅ 已完成：单进程 MCP 服务器、会话管理、审批机制、事件日志
2. 识别 MVP2 核心需求
   → ✅ 已识别：多进程并行、会话恢复、进程池管理、高级审批
3. 定义用户场景和验收标准
   → ✅ 已完成：见"用户场景与测试"章节
4. 分解功能需求
   → ✅ 已完成：8 大功能模块，38 项需求
5. 技术可行性验证
   → ⚠️  待验证：进程池管理、会话恢复机制
6. 返回状态
   → 📋 READY FOR PLANNING：需求已明确，待进入设计与规划阶段
```

---

## ⚡ 快速指南

- ✅ **重点**：用户需要什么功能、为什么需要
- ❌ **避免**：具体如何实现（无技术栈、API、代码结构细节）
- 👥 **面向**：业务干系人、产品经理、非技术决策者

---

## 产品愿景

### 背景

MVP1 已经成功实现了基于单进程 `codex mcp`
的 MCP 服务器，提供了完整的 MCP 协议支持、会话管理、审批机制和事件日志功能。然而，MVP1 存在以下限制：

1. **并发限制**：单进程只能串行执行任务，多个任务需要排队等待
2. **会话丢失**：进程崩溃后会话状态丢失，无法恢复
3. **扩展性不足**：无法管理其他类型的 agent（如 `claude code`）

### MVP2 目标

**MVP2 的核心目标是实现真正的多任务并行执行能力，提供会话恢复机制，并建立可扩展的架构**。

具体而言：

1. **进程池管理**：管理多个 `codex exec --json` 进程，实现真正并行执行
2. **会话恢复**：基于 Codex 原生 rollout 文件恢复崩溃后的会话
3. **高级审批**：支持多个并行审批请求的管理和批量操作
4. **架构扩展**：支持接入其他 agent 类型（如 `claude code`）
5. **可观测性**：提供丰富的指标收集和监控能力

### 核心价值

- **性能提升**：从串行执行到并行执行，吞吐量提升 N 倍（N = 进程池大小）
- **可靠性增强**：会话恢复机制确保任务不会因进程崩溃而丢失
- **灵活性提高**：支持多种 agent 类型，适应不同场景需求
- **运维友好**：丰富的指标和日志，便于监控和故障排查

---

## 用户场景与测试 _(必填)_

### 主要用户故事

**作为 codex-father 的用户**，我希望能够：

1. **同时运行多个独立任务**，而不是排队等待，提高工作效率
2. **在任务执行过程中遇到进程崩溃时**，系统能够自动恢复会话，继续执行，而不是从头开始
3. **管理多个并行任务的审批请求**，能够批量操作或逐个处理，避免终端 UI 混乱
4. **扩展到其他 agent 类型**（如 `claude code`），统一管理不同的 AI 助手
5. **监控系统运行状态**，了解并发数、耗时、审批命中率等关键指标

### 验收场景

#### 场景 1：多任务并行执行 ⭐

**Given**: 用户需要同时运行 3 个独立的开发任务

**When**:

- 用户通过 MCP 客户端发送 3 个 `tools/call` 请求
- codex-father 启动 3 个 `codex exec --json` 子进程

**Then**:

- 这 3 个任务能够**真正并行执行**，互不等待、互不阻塞
- 每个任务有独立的工作目录和日志文件
- 用户可以通过 `jobId` 跟踪每个任务的进度

**验收标准**:

```bash
# 同时发起 3 个任务
Task 1: 开始时间 10:00:00 → 结束时间 10:05:00 (5 分钟)
Task 2: 开始时间 10:00:01 → 结束时间 10:03:00 (3 分钟)
Task 3: 开始时间 10:00:02 → 结束时间 10:04:00 (4 分钟)

✅ 期望：所有任务在 5 分钟内完成（并行执行）
❌ 错误：总耗时 12 分钟（串行执行）
```

---

#### 场景 2：进程崩溃后会话恢复 ⭐

**Given**:

- 某个 `codex exec` 进程在执行过程中崩溃
- Codex 已将会话状态保存到 rollout 文件
  `CODEX_HOME/sessions/<conversation-id>.jsonl`

**When**:

- codex-father 检测到进程异常退出
- 系统读取 `rollout-ref.txt` 找到 rollout 文件路径
- 使用 `codex exec resume <session-id>` 命令重新启动进程

**Then**:

- 进程成功恢复，重新加载历史消息
- 任务从崩溃点继续执行，不需要重新开始
- 用户收到恢复成功的通知

**验收标准**:

```bash
# 崩溃前的会话状态
- 已完成 5 轮对话
- 已执行 3 个命令
- 正在等待第 4 个命令的审批

# 崩溃后恢复
✅ 恢复后状态：保留 5 轮对话 + 3 个命令执行记录
✅ 继续流程：直接显示第 4 个命令的审批请求
❌ 错误：从头开始，丢失所有历史
```

---

#### 场景 3：并行审批请求管理 ⭐

**Given**:

- 3 个任务同时运行
- 几乎同时需要审批（Task 1: `rm -rf build`, Task 2: `npm install`, Task 3:
  `git push`）

**When**:

- 审批请求几乎同时到达
- 终端 UI 排队显示审批请求

**Then**:

- 用户可以看到审批队列（显示 "1/3", "2/3", "3/3"）
- 用户可以逐个处理每个审批请求
- 用户可以选择"批量批准所有"或"批量拒绝所有"
- 每个任务收到对应的审批决策

**验收标准**:

```
┌─────────────────────────────────────────┐
│ 审批请求队列 (1/3)                      │
├─────────────────────────────────────────┤
│ 任务: task-abc123                       │
│ 命令: rm -rf build                      │
│ 工作目录: /workspace/project-a          │
│ 等待时间: 0:05                          │
├─────────────────────────────────────────┤
│ [A] 批准  [D] 拒绝  [S] 跳过            │
│ [B] 批量批准所有  [X] 批量拒绝所有      │
└─────────────────────────────────────────┘
```

---

#### 场景 4：扩展到其他 Agent 类型

**Given**:

- 用户希望集成 `claude code` 作为新的 agent 类型
- 在配置文件中添加新的 agent 定义

**When**:

```yaml
agents:
  - type: codex
    command: codex exec --json
    protocol: json-rpc
    event_parser: codex_event_parser

  - type: claude-code
    command: claude code --json-events
    protocol: json-stream
    event_parser: claude_code_event_parser
```

**Then**:

- codex-father 能够识别新的 agent 类型
- 用户可以通过 `agent_type: "claude-code"` 参数指定使用哪个 agent
- 系统能够管理 `claude code` 进程的生命周期
- 系统能够正确解析 `claude code` 的事件流

**验收标准**:

```bash
# 发起 claude code 任务
tools/call {
  name: "start-task",
  arguments: {
    prompt: "...",
    agent_type: "claude-code",
    model: "claude-3-5-sonnet"
  }
}

✅ 成功启动 claude code 进程
✅ 正确解析事件流
✅ 正确处理审批请求
```

---

#### 场景 5：指标收集和监控

**Given**:

- 系统运行了 1 小时
- 处理了 50 个任务

**When**:

- 用户查询系统指标
- 系统输出 JSON 格式的指标摘要

**Then**:

```json
{
  "time_range": {
    "start": "2025-10-01T10:00:00Z",
    "end": "2025-10-01T11:00:00Z"
  },
  "tasks": {
    "total": 50,
    "completed": 45,
    "failed": 3,
    "timeout": 2,
    "running": 0
  },
  "concurrency": {
    "max_parallel": 4,
    "avg_parallel": 2.8,
    "process_pool_size": 4
  },
  "performance": {
    "avg_duration_sec": 180,
    "p50_duration_sec": 120,
    "p95_duration_sec": 300,
    "p99_duration_sec": 450
  },
  "approvals": {
    "total_requests": 120,
    "auto_approved": 80,
    "manual_approved": 30,
    "denied": 10,
    "whitelist_hit_rate": 0.67
  },
  "failures": {
    "process_crash": 2,
    "timeout": 2,
    "user_cancelled": 1
  }
}
```

---

### 边界情况

#### 进程池管理

- **进程数量限制**：最大并行进程数由配置文件指定（默认：CPU 核数）
- **资源限制**：MVP2 阶段不实现 CPU/内存限额，依赖操作系统自然调度
- **进程清理**：已完成的进程必须及时清理，避免僵尸进程
- **进程池满载**：当进程池满时，新任务进入队列等待

#### 会话恢复机制

- **Rollout 文件依赖**：恢复机制**完全依赖** Codex 原生的 rollout 文件
- **文件损坏处理**：如果 rollout 文件损坏或丢失，无法恢复，记录错误并通知用户
- **备份策略**：可选择将 rollout 文件备份到 codex-father 的会话目录
- **恢复时机**：仅在进程崩溃时恢复，正常退出不触发恢复

#### 并行审批管理

- **审批队列**：多个审批请求排队，按时间顺序显示
- **批量操作**：支持批量批准/拒绝，但需要用户明确确认
- **超时处理**：每个审批请求独立计时，超时后自动拒绝（如果配置了超时）

#### Agent 扩展

- **协议要求**：新 agent 必须支持 JSON 事件流输出
- **事件解析**：需要为每个 agent 类型实现专用的事件解析器
- **兼容性**：不同 agent 的审批机制可能不同，需要适配

---

## 需求 _(必填)_

### 功能需求

#### FR-100 系列：进程池管理

- **FR-101**: 系统必须能够按需启动多个 `codex exec --json`
  子进程，实现真正的并行执行
- **FR-102**: 系统必须实现进程池管理器（ProcessOrchestrator）：
  - 维护进程列表（空闲/繁忙状态）
  - 监控进程状态（存活/崩溃）
  - 自动清理已退出的进程
  - 支持进程池扩容和缩容
- **FR-103**: 系统必须支持配置最大并行进程数量（默认建议：CPU 核数）
- **FR-104**: 系统必须能够将每个任务路由到独立的 `codex exec`
  进程，确保任务间互不干扰
- **FR-105**: 系统必须为每个 `codex exec` 进程创建独立的工作目录和日志目录
- **FR-106**: 当进程池满载时，新任务必须进入队列等待，不能拒绝或丢弃

#### FR-200 系列：会话恢复机制

- **FR-201**: 系统必须支持基于 Codex 原生 rollout 文件的会话恢复
- **FR-202**: 系统必须能够识别 Codex 写入的 rollout 文件路径：`CODEX_HOME/sessions/<conversation-id>.jsonl`
- **FR-203**: 系统必须在会话目录中创建 `rollout-ref.txt`
  文件，记录 rollout 文件的绝对路径
- **FR-204**: 当进程崩溃时，系统必须读取 `rollout-ref.txt`，使用
  `codex exec resume <session-id>` 命令恢复会话
- **FR-205**: 系统必须确保 Codex 的 rollout 文件不被意外删除或覆盖
- **FR-206**: 系统可选择将 rollout 文件备份到 codex-father 的会话目录（配置项）
- **FR-207**: codex-father 自己记录的 `events.jsonl` 和 `config.json`
  仅用于辅助监控和审计，**不用于会话恢复**
- **FR-208**: 如果 rollout 文件损坏或丢失，系统必须记录错误并通知用户，**不能强制恢复**

#### FR-300 系列：任务队列系统

- **FR-301**: 系统必须实现任务队列调度器（QueueScheduler）
- **FR-302**: 系统必须支持任务优先级：高、中、低三个级别
- **FR-303**: 系统必须支持队列持久化（JSON 或 SQLite），确保重启后队列不丢失
- **FR-304**: 系统必须支持重试机制：
  - 失败任务自动重试（最多 3 次，可配置）
  - 重试间隔：指数退避（1s, 2s, 4s...）
- **FR-305**: 系统必须支持死信队列（DLQ）：重试失败的任务进入 DLQ，等待人工处理
- **FR-306**: 系统必须提供队列监控接口：查询队列长度、等待时间、处理速度等

#### FR-400 系列：高级审批策略

- **FR-401**: 系统必须支持多个并行任务的审批请求排队管理
- **FR-402**: 系统必须提供审批队列 UI：
  - 显示当前审批请求的位置（如 "1/3"）
  - 显示队列中所有审批请求的概览
  - 支持快捷键批量操作
- **FR-403**: 系统必须支持批量审批操作：
  - 批量批准所有（需要明确确认）
  - 批量拒绝所有（需要明确确认）
  - 批量应用白名单（将当前命令加入白名单）
- **FR-404**: 系统必须支持基于时间的审批策略（可选）：
  - 工作时间（如 9:00-18:00）自动批准某些命令
  - 非工作时间自动拒绝或需要额外确认
- **FR-405**: 系统必须支持基于用户的审批策略（可选）：
  - 信任用户列表：某些用户的请求自动批准
  - 黑名单用户：某些用户的请求自动拒绝
- **FR-406**: 系统必须记录审批历史和统计：
  - 每个用户的审批次数、批准率、平均等待时间
  - 每个命令的审批次数、批准率
  - 白名单命中率

#### FR-500 系列：Agent 扩展架构

- **FR-501**: 系统的架构必须支持扩展到其他 agent 类型（如 `claude code` CLI）
- **FR-502**: 系统必须支持通过配置文件定义新 agent：
  - 启动命令模板（如 `claude code --json-events`）
  - 通信协议类型（json-rpc / json-stream / line-delimited-json）
  - 事件解析规则（自定义解析器）
  - 工作目录模板
- **FR-503**: 系统必须为每个 agent 类型实现专用的事件解析器接口
- **FR-504**: 系统必须支持 agent 类型识别：用户可以在任务参数中指定 `agent_type`
- **FR-505**: 系统必须能够管理不同 agent 的生命周期（启动、监控、通信、日志记录）

#### FR-600 系列：可观测性增强

- **FR-601**: 系统必须收集并暴露关键指标：
  - 并发数（当前并行任务数、最大并行数、平均并行数）
  - 耗时统计（平均、P50、P95、P99）
  - 审批统计（总请求数、自动批准、人工批准、拒绝、白名单命中率）
  - 超时/取消率
  - 失败原因分布（进程崩溃、超时、用户取消、审批拒绝）
- **FR-602**: 系统必须将指标以 JSON 格式输出到日志文件
- **FR-603**: 系统必须支持指标查询接口：
  - 按时间范围查询（如最近 1 小时、最近 1 天）
  - 按任务类型查询
  - 按 agent 类型查询
- **FR-604**: 系统必须支持结构化日志输出（JSON 格式），便于日志分析工具处理
- **FR-605**: 系统必须支持分布式追踪（可选）：
  - 为每个任务生成唯一的 trace_id
  - 记录每个关键步骤的 span（如：接收请求、启动进程、执行命令、等待审批）
  - 输出符合 OpenTelemetry 标准的追踪数据

#### FR-700 系列：性能优化

- **FR-701**: 系统必须支持事件批量处理，减少 I/O 开销
- **FR-702**: 系统必须实现内存池管理，减少频繁分配
- **FR-703**: 系统必须支持进程间通信优化（IPC / 共享内存，可选）
- **FR-704**: 系统必须支持资源使用监控和限流：
  - 监控每个进程的 CPU、内存使用情况
  - 当资源使用超过阈值时，暂停新任务调度
  - 记录资源使用统计

#### FR-800 系列：配置管理增强

- **FR-801**: 系统必须支持热重载配置：
  - 监听配置文件变化（使用文件监听器）
  - 配置变化后自动重新加载
  - 不中断正在运行的任务
- **FR-802**: 系统必须支持配置验证和迁移：
  - 启动时验证配置文件格式
  - 自动迁移旧版本配置到新版本
  - 提供配置文件模板和示例
- **FR-803**: 系统必须支持环境变量覆盖配置：
  - 支持通过环境变量覆盖配置文件中的值
  - 环境变量优先级高于配置文件
- **FR-804**: 系统必须提供配置文件模板生成命令：
  - `codex-father config init` 生成默认配置
  - `codex-father config validate` 验证配置文件

---

### 非功能需求

#### NFR-001: 性能要求

- **并发性能**：支持至少 4 个并行任务（4 核 CPU）
- **响应时间**：tools/call 快速返回时间 < 500ms（与 MVP1 一致）
- **内存占用**：每个进程内存 < 200MB，总内存 < 1GB（4 进程）

#### NFR-002: 可靠性要求

- **进程崩溃恢复**：90% 的崩溃场景能够成功恢复会话
- **数据持久化**：队列、配置、日志必须持久化，重启后不丢失
- **错误处理**：所有错误必须有明确的错误码和错误消息

#### NFR-003: 可维护性要求

- **代码质量**：保持 MVP1 的高质量标准（SOLID 5/5、重复率 < 5%）
- **测试覆盖率**：单元测试覆盖率 ≥ 80%、集成测试覆盖率 100%
- **文档完整性**：所有新功能必须有对应的文档和示例

#### NFR-004: 兼容性要求

- **向后兼容**：MVP2 必须与 MVP1 的配置文件和日志格式兼容
- **API 稳定性**：MCP 协议接口不变，内部实现可以改变
- **平台支持**：支持 Linux、macOS、Docker 容器环境

---

### 关键实体 _(特性涉及数据时包含)_

#### ProcessOrchestrator（进程编排器）

**描述**：管理多个 `codex exec` 进程的生命周期和调度

**属性**：

- `process_pool`: 进程池（空闲/繁忙状态）
- `max_processes`: 最大并行进程数
- `active_processes`: 当前活跃进程列表
- `process_metrics`: 进程性能指标

**方法**：

- `start_process(task)`: 启动新进程
- `stop_process(process_id)`: 停止进程
- `get_available_process()`: 获取空闲进程
- `monitor_processes()`: 监控进程健康状态

---

#### QueueScheduler（队列调度器）

**描述**：管理任务队列、优先级和重试逻辑

**属性**：

- `task_queue`: 任务队列（高/中/低优先级）
- `dlq`: 死信队列
- `retry_policy`: 重试策略配置
- `queue_metrics`: 队列统计指标

**方法**：

- `enqueue(task, priority)`: 任务入队
- `dequeue()`: 任务出队
- `retry(task)`: 任务重试
- `move_to_dlq(task)`: 移入死信队列

---

#### SessionRecoveryManager（会话恢复管理器）

**描述**：负责崩溃后的会话恢复逻辑

**属性**：

- `rollout_file_path`: Codex 原生 rollout 文件路径
- `recovery_strategy`: 恢复策略（自动/手动）
- `backup_enabled`: 是否启用备份

**方法**：

- `locate_rollout_file(session_id)`: 定位 rollout 文件
- `restore_session(session_id)`: 恢复会话
- `backup_rollout_file(source, dest)`: 备份 rollout 文件
- `validate_rollout_file(path)`: 验证 rollout 文件完整性

---

#### ApprovalQueue（审批队列）

**描述**：管理多个并行任务的审批请求

**属性**：

- `queue`: 审批请求队列
- `current_index`: 当前处理的审批请求索引
- `batch_mode`: 批量操作模式

**方法**：

- `add_request(request)`: 添加审批请求
- `next_request()`: 获取下一个审批请求
- `batch_approve_all()`: 批量批准所有
- `batch_deny_all()`: 批量拒绝所有

---

#### AgentDefinition（Agent 定义）

**描述**：定义外部 agent 的配置信息

**属性**：

- `type`: Agent 类型（codex / claude-code / ...）
- `command_template`: 启动命令模板
- `protocol`: 通信协议类型
- `event_parser`: 事件解析器
- `work_dir_template`: 工作目录模板

**方法**：

- `build_command(task)`: 构建启动命令
- `parse_event(raw_event)`: 解析事件

---

#### MetricsSummary（指标摘要）

**描述**：系统运行指标的汇总数据

**属性**：

- `time_range`: 时间范围
- `tasks`: 任务统计
- `concurrency`: 并发统计
- `performance`: 性能统计
- `approvals`: 审批统计
- `failures`: 失败统计

**方法**：

- `to_json()`: 输出 JSON 格式
- `calculate_metrics(events)`: 从事件日志计算指标

---

## 审查与验收清单

### 内容质量

- [x] 无实现细节（语言、框架、API）
- [x] 聚焦用户价值和业务需求
- [x] 面向非技术干系人撰写
- [x] 所有必填章节已完成

### 需求完整性

- [x] 所有功能需求明确且可测试
- [x] 非功能需求（性能、可靠性）已定义
- [x] 边界情况已识别
- [x] 验收场景清晰可衡量
- [x] MVP1/MVP2 边界清晰

### 风险识别

- [ ] **技术风险**：进程池管理复杂度较高，需要验证技术可行性
- [ ] **依赖风险**：会话恢复完全依赖 Codex 的 rollout 文件，如果 Codex 改变文件格式，会导致恢复失败
- [ ] **用户体验风险**：并行审批 UI 设计复杂，需要原型验证

---

## 下一步行动

1. **技术验证**：
   - [ ] 验证多进程管理的技术可行性
   - [ ] 验证 Codex rollout 文件的格式和恢复机制
   - [ ] 验证并行审批 UI 的用户体验

2. **设计阶段**：
   - [ ] 创建 `mvp2-spec.md`（技术规范）
   - [ ] 设计架构图和数据模型
   - [ ] 定义 API 和接口

3. **规划阶段**：
   - [ ] 创建 `mvp2-tasks.md`（任务分解）
   - [ ] 估算开发工时
   - [ ] 制定迭代计划

---

**文档版本**: 1.0.0 **创建日期**: 2025-10-01 **最后更新**: 2025-10-01
**维护者**: codex-father 团队
