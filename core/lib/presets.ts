import fs from 'node:fs';
import os from 'node:os';
import path from 'node:path';

import { CodeQualityStandard } from './models/code-quality';
import { TestArchitectureFramework } from './models/test-architecture';
import type { CodexConfig } from './models/configuration';

export const DEFAULT_TEST_FRAMEWORK: TestArchitectureFramework = {
  id: 'default-tests',
  framework: 'vitest',
  layers: [
    {
      name: 'unit',
      directory: 'core',
      patterns: ['**/*.test.ts'],
      tools: ['vitest'],
      parallelExecution: true,
      timeout: 30000,
    },
  ],
  coverageRequirements: [{ scope: 'overall', type: 'line', threshold: 80, enforcement: 'strict' }],
  automationStrategy: { ciProvider: 'github-actions', triggers: ['pr'] },
  containerizedTesting: { enabled: false },
};

export const DEFAULT_CODE_QUALITY: CodeQualityStandard = {
  id: 'default-quality',
  language: 'typescript',
  linting: { tool: 'eslint', configFile: 'eslint.config.js', rules: {}, ignorePatterns: [] },
  formatting: { tool: 'prettier', configFile: '.prettierrc' },
  qualityGates: [
    { name: 'unit-coverage', metric: 'lines', threshold: 80, operator: 'gte', required: true },
  ],
  reviewChecklist: [{ id: 'doc', text: 'Updated docs', required: true }],
};

export interface AutoFixProfile {
  name: string;
  config: CodexConfig;
  metadata: {
    createdAt: string;
    reason: string;
    originalConfig: CodexConfig;
  };
}

export function createAutoFixProfile(
  original: CodexConfig,
  fixed: CodexConfig,
  reason: string
): AutoFixProfile {
  return {
    name: 'codex-father-auto-fix',
    config: fixed,
    metadata: {
      createdAt: new Date().toISOString(),
      reason,
      originalConfig: original,
    },
  };
}

export async function writeProfile(profile: AutoFixProfile, configPath?: string): Promise<void> {
  const targetPath = resolveConfigPath(configPath);

  await fs.promises.mkdir(path.dirname(targetPath), { recursive: true });

  const existing = fs.existsSync(targetPath) ? await fs.promises.readFile(targetPath, 'utf-8') : '';
  const nextContent = mergeProfileContent(existing, profile);
  await fs.promises.writeFile(targetPath, nextContent, 'utf-8');
}

export async function readProfile(
  profileName: string,
  configPath?: string
): Promise<AutoFixProfile | null> {
  const targetPath = resolveConfigPath(configPath);
  if (!fs.existsSync(targetPath)) {
    return null;
  }

  const content = await fs.promises.readFile(targetPath, 'utf-8');
  return extractProfile(content, profileName);
}

function resolveConfigPath(configPath?: string): string {
  return configPath || path.join(os.homedir(), '.codex', 'config.toml');
}

function mergeProfileContent(existing: string, profile: AutoFixProfile): string {
  const sanitized = removeProfile(existing, profile.name);
  const block = renderProfile(profile);

  const separator = sanitized.trim().length > 0 ? '\n\n' : '';
  const combined = `${sanitized.trimEnd()}${separator}${block}`.trimEnd();
  return combined.length > 0 ? `${combined}\n` : `${block}\n`;
}

function removeProfile(content: string, profileName: string): string {
  if (!content) return '';
  const escaped = escapeRegExp(profileName);
  const providerPattern = new RegExp(
    `\\s*\\[profiles\\.${escaped}\\.model_providers\\.[^\\]]+\\][^\\[]*`,
    'g'
  );
  const withoutProviders = content.replace(providerPattern, '');
  const mainPattern = new RegExp(`(?:\\s*#.*\\n)*\\s*\\[profiles\\.${escaped}\\][^\\[]*`, 'g');
  return withoutProviders.replace(mainPattern, '').trimEnd();
}

function renderProfile(profile: AutoFixProfile): string {
  const lines: string[] = [];
  lines.push(`# Auto-generated by codex-father on ${profile.metadata.createdAt}`);
  lines.push(`# Reason: ${profile.metadata.reason}`);
  lines.push('');
  const section = `profiles.${profile.name}`;
  lines.push(`[${section}]`);

  appendTomlField(lines, 'model', profile.config.model);
  appendTomlField(lines, 'approval_policy', profile.config.approval_policy);
  appendTomlField(lines, 'sandbox', profile.config.sandbox);
  appendTomlField(lines, 'cwd', profile.config.cwd);
  appendTomlBoolean(lines, 'include_plan_tool', profile.config.include_plan_tool);
  appendTomlBoolean(lines, 'include_apply_patch_tool', profile.config.include_apply_patch_tool);

  const providers = profile.config.model_providers ?? {};
  for (const [provider, providerConfig] of Object.entries(providers)) {
    if (!providerConfig) continue;
    const providerSection = `[${section}.model_providers.${provider}]`;
    lines.push(providerSection);
    for (const [key, value] of Object.entries(providerConfig)) {
      if (value === undefined) continue;
      if (typeof value === 'boolean') {
        appendTomlBoolean(lines, key, value);
      } else {
        appendTomlField(lines, key, value as string | number);
      }
    }
  }

  return lines.join('\n');
}

function appendTomlField(lines: string[], key: string, value: string | number | undefined): void {
  if (value === undefined) return;
  lines.push(`${key} = "${String(value)}"`);
}

function appendTomlBoolean(lines: string[], key: string, value: boolean | undefined): void {
  if (value === undefined) return;
  lines.push(`${key} = ${value ? 'true' : 'false'}`);
}

function extractProfile(content: string, profileName: string): AutoFixProfile | null {
  const escaped = escapeRegExp(profileName);
  const pattern = new RegExp(
    `(?:#\\s*Auto-generated by codex-father on\\s*(?<created>.+?)\\s*#\\s*Reason:\\s*(?<reason>.+?)\\n)?\\s*\\[profiles\\.${escaped}\\](?<body>[^\\[]*)`,
    's'
  );
  const match = content.match(pattern);
  if (!match || !match.groups) {
    return null;
  }

  const body = match.groups.body ?? '';
  const config: CodexConfig = {};

  const model = extractString(body, 'model');
  if (model) config.model = model;
  const approval = extractString(body, 'approval_policy');
  if (approval) config.approval_policy = approval as CodexConfig['approval_policy'];
  const sandbox = extractString(body, 'sandbox');
  if (sandbox) config.sandbox = sandbox as CodexConfig['sandbox'];
  const cwd = extractString(body, 'cwd');
  if (cwd) config.cwd = cwd;
  const includePlan = extractBoolean(body, 'include_plan_tool');
  if (includePlan !== null) config.include_plan_tool = includePlan;
  const includePatch = extractBoolean(body, 'include_apply_patch_tool');
  if (includePatch !== null) config.include_apply_patch_tool = includePatch;

  // 解析 model_providers.*
  const providerRegex = new RegExp(
    `\\[profiles\\.${escaped}\\.model_providers\\.(?<provider>[\\w-]+)\\]([^\\[]*)`,
    'gs'
  );
  let providerMatch: RegExpExecArray | null;
  while ((providerMatch = providerRegex.exec(content)) !== null) {
    const providerName = providerMatch.groups?.provider;
    const providerBody = providerMatch[2] ?? '';
    if (!providerName) continue;

    const providerConfig: Record<string, string | boolean> = {};
    const keys = providerBody.split('\n');
    for (const line of keys) {
      const trimmed = line.trim();
      if (!trimmed || trimmed.startsWith('#')) continue;
      const [key, rawValue] = trimmed.split('=', 2).map((part) => part?.trim());
      if (!key || !rawValue) continue;
      if (/^(true|false)$/i.test(rawValue)) {
        providerConfig[key] = /^true$/i.test(rawValue);
      } else {
        providerConfig[key] = rawValue.replace(/^"(.*)"$/, '$1');
      }
    }

    if (Object.keys(providerConfig).length === 0) continue;
    config.model_providers = config.model_providers ?? {};
    config.model_providers[providerName as keyof NonNullable<typeof config.model_providers>] =
      providerConfig as any;
  }

  return {
    name: profileName,
    config,
    metadata: {
      createdAt: (match.groups.created ?? '').trim() || new Date().toISOString(),
      reason: (match.groups.reason ?? '').trim() || 'Unknown reason',
      originalConfig: config,
    },
  };
}

function extractString(body: string, key: string): string | undefined {
  const match = body.match(new RegExp(`${key}\\s*=\\s*"([^"]*)"`, 'i'));
  return match?.[1];
}

function extractBoolean(body: string, key: string): boolean | null {
  const match = body.match(new RegExp(`${key}\\s*=\\s*(true|false)`, 'i'));
  if (!match) return null;
  return /^true$/i.test(match[1]);
}

function escapeRegExp(input: string): string {
  return input.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
