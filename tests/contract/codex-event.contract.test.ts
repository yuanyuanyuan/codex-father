import { describe, it, expect } from 'vitest';
import Ajv from 'ajv';
import schema from '../schemas/codex-event.schema.json';

const ajv = new Ajv({ strict: false });

describe('MCP Contract: codex/event', () => {
  describe('Notification Validation', () => {
    const notificationSchema = schema.definitions
      ? { ...schema.request, definitions: schema.definitions }
      : schema.request;
    const validateNotification = ajv.compile(notificationSchema);

    it('should validate task_started event with conversation context', () => {
      const event = {
        type: 'task_started',
        conversationId: 'c7b0a1d2-e3f4-5678-90ab-cdef12345678',
        timestamp: '2025-10-04T10:00:00Z',
      };

      expect(validateNotification(event)).toBe(true);
    });

    it('should validate agent_message event with streaming role information', () => {
      const event = {
        type: 'agent_message',
        conversationId: 'c7b0a1d2-e3f4-5678-90ab-cdef12345678',
        message: 'Processing your requestâ€¦',
        role: 'assistant',
      };

      expect(validateNotification(event)).toBe(true);
    });

    it('should validate apply_patch_approval_request event with change map', () => {
      const event = {
        type: 'apply_patch_approval_request',
        callId: 'patch-42',
        reason: 'Applying diff generated by Codex agent',
        changes: {
          'src/app.ts': {
            path: 'src/app.ts',
            type: 'modify',
            diff: '--- old\n+++ new',
          },
        },
      };

      expect(validateNotification(event)).toBe(true);
    });

    it('should accept events with _meta.requestId for correlation', () => {
      const event = {
        type: 'task_complete',
        conversationId: 'conv-123',
        _meta: {
          requestId: 'req-789',
        },
      };

      expect(validateNotification(event)).toBe(true);
    });

    it('should reject events missing type discriminant', () => {
      const event = {
        conversationId: 'conv-123',
      };

      expect(validateNotification(event)).toBe(false);
    });

    it('should reject apply_patch_approval_request without change details', () => {
      const event = {
        type: 'apply_patch_approval_request',
        callId: 'patch-42',
      };

      expect(validateNotification(event)).toBe(false);
    });

    it('should validate token_count event with usage snapshot', () => {
      const event = {
        type: 'token_count',
        info: {
          tokenUsage: {
            totalTokenUsage: {
              inputTokens: 1200,
              cachedInputTokens: 0,
              outputTokens: 600,
              reasoningOutputTokens: 200,
              totalTokens: 2000,
            },
            lastTokenUsage: {
              inputTokens: 200,
              cachedInputTokens: 0,
              outputTokens: 100,
              reasoningOutputTokens: 50,
              totalTokens: 350,
            },
            modelContextWindow: 32000,
          },
          rateLimits: null,
        },
      };

      expect(validateNotification(event)).toBe(true);
    });
  });

  describe('Response Validation', () => {
    const validateResponse = ajv.compile(schema.response);

    it('should allow null response for notifications', () => {
      expect(validateResponse(null)).toBe(true);
    });

    it('should reject non-null response payload', () => {
      expect(validateResponse({})).toBe(false);
    });
  });
});
