import { describe, it, expect, beforeEach } from 'vitest';
import os from 'node:os';
import path from 'node:path';
import fs from 'node:fs';
import { fileURLToPath } from 'node:url';

import type { CodexConfig } from '../../src/lib/configSchema';
import {
  createAutoFixProfile,
  writeProfile,
  readProfile,
  type AutoFixProfile,
} from '../../src/lib/profileManager';

function tmpConfigPath(suffix = ''): string {
  const base = path.join(
    os.tmpdir(),
    `codex-father-profile-test-${Date.now()}-${Math.random().toString(36).slice(2)}`
  );
  const dir = path.join(base, '.codex');
  fs.mkdirSync(dir, { recursive: true });
  return path.join(dir, `config${suffix}.toml`);
}

describe('profileManager - createAutoFixProfile', () => {
  it('创建的 Profile 名称为 codex-father-auto-fix，包含时间戳与原因，config 正确', () => {
    const original: CodexConfig = {
      model: 'gpt-5-codex',
      approval_policy: 'on-request',
      sandbox: 'workspace-write',
      model_providers: { openai: { wire_api: 'chat' } },
    };
    const fixed: CodexConfig = {
      ...original,
      model_providers: { openai: { wire_api: 'responses' } },
    };
    const reason = 'Fixed wire_api mismatch for gpt-5-codex';

    const profile = createAutoFixProfile(original, fixed, reason);
    expect(profile.name).toBe('codex-father-auto-fix');
    expect(profile.config).toEqual(fixed);
    expect(profile.metadata.reason).toBe(reason);
    // ISO 8601 时间戳
    expect(typeof profile.metadata.createdAt).toBe('string');
    expect(new Date(profile.metadata.createdAt).toString()).not.toBe('Invalid Date');
    // 可选保存原始配置
    expect(profile.metadata.originalConfig).toBeTruthy();
  });
});

describe('profileManager - writeProfile', () => {
  it('写入到临时文件，TOML 包含注释和正确的段', async () => {
    const configPath = tmpConfigPath();
    const fixed: CodexConfig = {
      model: 'gpt-5-codex',
      approval_policy: 'on-failure',
      sandbox: 'workspace-write',
      model_providers: { openai: { wire_api: 'responses' } },
    };
    const profile: AutoFixProfile = createAutoFixProfile(
      fixed,
      fixed,
      'Fixed wire_api mismatch for gpt-5-codex'
    );

    await writeProfile(profile, configPath);
    const text = fs.readFileSync(configPath, 'utf-8');

    expect(text).toContain('# Auto-generated by codex-father on');
    expect(text).toContain('# Reason: Fixed wire_api mismatch for gpt-5-codex');
    expect(text).toContain('[profiles.codex-father-auto-fix]');
    expect(text).toContain('model = "gpt-5-codex"');
    expect(text).toContain('approval_policy = "on-failure"');
    expect(text).toContain('sandbox = "workspace-write"');
    expect(text).toContain('[profiles.codex-father-auto-fix.model_providers.openai]');
    expect(text).toContain('wire_api = "responses"');
  });

  it('~/.codex 目录不存在时自动创建', async () => {
    const base = path.join(
      os.tmpdir(),
      `codex-father-profile-test-${Date.now()}-${Math.random().toString(36).slice(2)}`
    );
    const configPath = path.join(base, '.codex', 'config.toml');
    // 不主动创建目录，由 writeProfile 负责
    const fixed: CodexConfig = {
      model: 'gpt-5-codex',
      model_providers: { openai: { wire_api: 'responses' } },
    };
    const profile: AutoFixProfile = createAutoFixProfile(fixed, fixed, 'init');

    await writeProfile(profile, configPath);
    expect(fs.existsSync(configPath)).toBe(true);
  });
});

describe('profileManager - readProfile', () => {
  it('正确读取已存在的 Profile（含注释解析）', async () => {
    const configPath = tmpConfigPath('-read');
    const fixed: CodexConfig = {
      model: 'gpt-5-codex',
      approval_policy: 'on-failure',
      sandbox: 'workspace-write',
      model_providers: { openai: { wire_api: 'responses' } },
    };
    const reason = 'Fixed wire_api mismatch for gpt-5-codex';
    const profile: AutoFixProfile = createAutoFixProfile(fixed, fixed, reason);
    await writeProfile(profile, configPath);

    const read = await readProfile('codex-father-auto-fix', configPath);
    expect(read).toBeTruthy();
    expect(read?.name).toBe('codex-father-auto-fix');
    expect(read?.config).toEqual(fixed);
    expect(read?.metadata.reason).toBe(reason);
    expect(read?.metadata.createdAt).toBe(profile.metadata.createdAt);
  });

  it('文件不存在时返回 null', async () => {
    const configPath = path.join(
      os.tmpdir(),
      `codex-father-profile-test-missing-${Date.now()}`,
      '.codex',
      'config.toml'
    );
    const res = await readProfile('codex-father-auto-fix', configPath);
    expect(res).toBeNull();
  });

  it('Profile 不存在时返回 null', async () => {
    const configPath = tmpConfigPath('-none');
    const text = `# some other profile\n[profiles.default]\nmodel = "gpt-4"\n`;
    fs.writeFileSync(configPath, text, 'utf-8');
    const res = await readProfile('codex-father-auto-fix', configPath);
    expect(res).toBeNull();
  });
});

describe('profileManager - 集成：多次写入同名 Profile 覆盖', () => {
  it('只保留一个段，读取到最新配置与注释', async () => {
    const configPath = tmpConfigPath('-overwrite');
    const cfg1: CodexConfig = {
      model: 'gpt-5-codex',
      approval_policy: 'on-request',
      model_providers: { openai: { wire_api: 'responses' } },
    };
    const p1 = createAutoFixProfile(cfg1, cfg1, 'first write');
    await writeProfile(p1, configPath);

    const cfg2: CodexConfig = {
      model: 'gpt-5-codex',
      approval_policy: 'on-failure',
      sandbox: 'workspace-write',
      model_providers: { openai: { wire_api: 'responses' } },
    };
    const p2 = createAutoFixProfile(cfg2, cfg2, 'second write');
    await writeProfile(p2, configPath);

    const text = fs.readFileSync(configPath, 'utf-8');
    const occurrences = (text.match(/\[profiles\.codex-father-auto-fix\]/g) || []).length;
    expect(occurrences).toBe(1);
    expect(text).toContain('# Reason: second write');

    const read = await readProfile('codex-father-auto-fix', configPath);
    expect(read?.config).toEqual(cfg2);
    expect(read?.metadata.reason).toBe('second write');
  });
});
