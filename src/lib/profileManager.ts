import fs from 'node:fs';
import path from 'node:path';
import os from 'node:os';
import { CodexConfig } from './configSchema';

export interface AutoFixProfile {
  name: 'codex-father-auto-fix';
  config: CodexConfig;
  metadata: {
    createdAt: string; // ISO 8601
    reason: string;
    originalConfig?: Partial<CodexConfig>;
  };
}

const PROFILE_NAME: AutoFixProfile['name'] = 'codex-father-auto-fix';

export function createAutoFixProfile(
  originalConfig: CodexConfig,
  fixedConfig: CodexConfig,
  reason: string
): AutoFixProfile {
  return {
    name: PROFILE_NAME,
    config: fixedConfig,
    metadata: {
      createdAt: new Date().toISOString(),
      reason,
      originalConfig,
    },
  };
}

function resolveConfigPath(configPath?: string): string {
  if (configPath && configPath.length > 0) {
    return configPath;
  }
  const home = os.homedir();
  return path.join(home, '.codex', 'config.toml');
}

function ensureDirForFile(filePath: string) {
  const dir = path.dirname(filePath);
  fs.mkdirSync(dir, { recursive: true });
}

function stringifyTomlValue(v: unknown): string {
  if (v === null || v === undefined) {
    return '""';
  }
  const t = typeof v;
  if (t === 'boolean') {
    return v ? 'true' : 'false';
  }
  if (t === 'number') {
    return String(v);
  }
  if (t === 'string') {
    // escape quotes and backslashes minimally
    const s = (v as string).replace(/\\/g, '\\\\').replace(/"/g, '\\"');
    return `"${s}"`;
  }
  // Fallback to JSON for objects/arrays; TOML inline tables are not used here.
  return stringifyTomlValue(JSON.stringify(v));
}

function generateProfileToml(profile: AutoFixProfile): string {
  const { config, metadata } = profile;
  const lines: string[] = [];
  lines.push(`# Auto-generated by codex-father on ${metadata.createdAt}`);
  lines.push(`# Reason: ${metadata.reason}`);
  lines.push(`[profiles.${PROFILE_NAME}]`);

  const topLevel: Record<string, unknown> = { ...config } as any;
  const modelProviders = (topLevel as any).model_providers as
    | Record<string, Record<string, unknown>>
    | undefined;
  delete (topLevel as any).model_providers;

  for (const [key, val] of Object.entries(topLevel)) {
    if (val === undefined) {
      continue;
    }
    lines.push(`${key} = ${stringifyTomlValue(val)}`);
  }

  if (modelProviders && typeof modelProviders === 'object') {
    for (const [provider, cfg] of Object.entries(modelProviders)) {
      lines.push('');
      lines.push(`[profiles.${PROFILE_NAME}.model_providers.${provider}]`);
      for (const [k, v] of Object.entries(cfg || {})) {
        if (v === undefined) {
          continue;
        }
        lines.push(`${k} = ${stringifyTomlValue(v)}`);
      }
    }
  }

  lines.push('');
  return lines.join('\n');
}

function sectionNameFromHeader(line: string): string | null {
  const m = line.match(/^\s*\[([^\]]+)\]\s*$/);
  return m ? m[1].trim() : null;
}

function isTargetProfileSection(section: string, profileName: string): boolean {
  return section === `profiles.${profileName}` || section.startsWith(`profiles.${profileName}.`);
}

function removeExistingProfileBlocks(content: string, profileName: string): string {
  const lines = content.split(/\r?\n/);
  const out: string[] = [];
  let inTarget = false;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const sec = sectionNameFromHeader(line);
    if (sec) {
      if (isTargetProfileSection(sec, profileName)) {
        // Drop header comment lines immediately preceding if they match our markers
        // Remove up to 2 previous lines if they are our generated comments
        for (let back = 1; back <= 3; back++) {
          const idx = out.length - 1;
          if (idx < 0) {
            break;
          }
          const prev = out[idx];
          if (/^\s*$/.test(prev)) {
            out.pop();
            continue;
          }
          if (prev.startsWith('# Auto-generated by codex-father') || prev.startsWith('# Reason:')) {
            out.pop();
            continue;
          }
          break;
        }
        inTarget = true;
        continue; // skip this header line
      } else if (inTarget) {
        // Leaving target block, emit this new section and reset flag
        inTarget = false;
        out.push(line);
        continue;
      }
    }
    if (inTarget) {
      // Skip any lines (keys/comments/blank) within target profile sections
      continue;
    }
    out.push(line);
  }
  // Trim trailing blank lines
  while (out.length > 0 && /^\s*$/.test(out[out.length - 1])) {
    out.pop();
  }
  return out.join('\n');
}

export async function writeProfile(profile: AutoFixProfile, configPath?: string): Promise<void> {
  const filePath = resolveConfigPath(configPath);
  ensureDirForFile(filePath);

  const newBlock = generateProfileToml(profile);
  if (!fs.existsSync(filePath)) {
    fs.writeFileSync(filePath, `${newBlock}\n`, 'utf-8');
    return;
  }
  const existing = fs.readFileSync(filePath, 'utf-8');
  const without = removeExistingProfileBlocks(existing, PROFILE_NAME);
  const combined = without.length > 0 ? `${without}\n\n${newBlock}\n` : `${newBlock}\n`;
  fs.writeFileSync(filePath, combined, 'utf-8');
}

function stripTomlInlineComment(line: string): string {
  let inStr = false;
  let esc = false;
  for (let i = 0; i < line.length; i++) {
    const ch = line[i];
    if (inStr) {
      if (esc) {
        esc = false;
      } else if (ch === '\\') {
        esc = true;
      } else if (ch === '"') {
        inStr = false;
      }
      continue;
    } else {
      if (ch === '"') {
        inStr = true;
        continue;
      }
      if (ch === '#') {
        return line.slice(0, i).trimEnd();
      }
    }
  }
  return line.trimEnd();
}

function parseTomlValue(v: string): any {
  const s = v.trim();
  if (s === 'true') {
    return true;
  }
  if (s === 'false') {
    return false;
  }
  if (/^".*"$/.test(s)) {
    const inner = s.slice(1, -1);
    return inner.replace(/\\"/g, '"').replace(/\\\\/g, '\\');
  }
  if (/^[0-9]+(\.[0-9]+)?$/.test(s)) {
    return Number(s);
  }
  // fallback: return raw string
  return s;
}

export async function readProfile(
  profileName: string,
  configPath?: string
): Promise<AutoFixProfile | null> {
  const filePath = resolveConfigPath(configPath);
  if (!fs.existsSync(filePath)) {
    return null;
  }
  const content = fs.readFileSync(filePath, 'utf-8');
  const lines = content.split(/\r?\n/);

  const baseHeader = `[profiles.${profileName}]`;
  let baseHeaderIdx = -1;
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].trim() === baseHeader) {
      baseHeaderIdx = i;
      break;
    }
  }
  if (baseHeaderIdx === -1) {
    return null;
  }

  // Extract metadata from preceding comments
  let createdAt: string | undefined;
  let reason: string | undefined;
  for (let i = baseHeaderIdx - 1; i >= 0 && i >= baseHeaderIdx - 5; i--) {
    const l = lines[i].trim();
    if (l.startsWith('# Auto-generated by codex-father on ')) {
      createdAt = l.replace('# Auto-generated by codex-father on ', '').trim();
    } else if (l.startsWith('# Reason:')) {
      reason = l.replace('# Reason:', '').trim();
    } else if (l === '') {
      continue;
    } else if (!l.startsWith('#')) {
      break;
    }
  }

  const cfg: any = {};
  let currentSection: string | null = null;
  let currentProvider: string | null = null;

  for (let i = baseHeaderIdx; i < lines.length; i++) {
    const raw = lines[i];
    const sec = sectionNameFromHeader(raw);
    if (sec) {
      currentSection = sec;
      if (!isTargetProfileSection(sec, profileName)) {
        break;
      } // left the target profile area
      // handle nested provider section
      const m = sec.match(/^profiles\.[^.]+\.model_providers\.(.+)$/);
      currentProvider = m ? m[1] : null;
      continue;
    }
    if (!currentSection) {
      continue;
    }
    // only parse within target section
    if (!isTargetProfileSection(currentSection, profileName)) {
      break;
    }

    const line = stripTomlInlineComment(raw).trim();
    if (!line || line.startsWith('#')) {
      continue;
    }
    const kv = line.split('=');
    if (kv.length < 2) {
      continue;
    }
    const key = kv[0].trim();
    const valStr = kv.slice(1).join('=').trim();
    const val = parseTomlValue(valStr);
    if (currentProvider) {
      cfg.model_providers = cfg.model_providers || {};
      cfg.model_providers[currentProvider] = cfg.model_providers[currentProvider] || {};
      cfg.model_providers[currentProvider][key] = val;
    } else {
      cfg[key] = val;
    }
  }

  const profile: AutoFixProfile = {
    name: PROFILE_NAME,
    config: cfg,
    metadata: {
      createdAt: createdAt || new Date(0).toISOString(),
      reason: reason || '',
    },
  };
  return profile;
}
